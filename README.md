# Very Long FileName в Linux
В проекте приведена работа по исследованию различных файловых систем в Linux на пример максимальной длины имени файлов 
и написанию патча для ядра для приведения данного параметра к единому значению.

## Statfs
Проверка файловых систем выполнялась на Ubuntu c версией ядра 5.8.0 с помощью стандартной библиотечной функции statfs, которая по пути до файла/директории позволяет узнать информацию о файловой
системе в которой он располагается. 

## Эмуляция раздела диска с необходимой файловой системой
Командой truncate создавался файл размером 1 Гб, вызовом mkfs в этот файл добавлялась рассматриваемая файловая система, затем с помощью команды mount данный файл, с указанием типа файловой системы, монтировался в пустую директорию и на ней запускалась тестовая программа. После выполнения теста вызовом umount раздел отмонтировался и файл с директорией удалялись.

## Запуск тестов
Для корректной работы скрипта тестирования необходимо установить EEPM (Etersoft EPM package manager): [EEPM](https://github.com/Etersoft/eepm).

## FAT
Результат работы тестовой программы:

```
tf_type: FAT 0x4d44
tf_namelen: 1530
```

Рассмотрим как это значение вычисляется в ядре:

```
f_namelen = (sbi->options.isvfat ? FAT_LFN_LEN : 12) * NLS_MAX_CHARSET_SIZE;
```
Константа FAT\_LFN\_LEN, равная 255 находится в файле include/uapi/linux/msdos_fs.h

NLS\_MAX\_CHARSET\_SIZE находится в файле include/linux/nls.h и равняется 6, хотя с ноября 2003 года пятый и шестой байты в UTF-8 уже не используются при кодировании, 
для обеспечения совместимости с UTF-16.

Таким образом, мы убедились, что полученное в тестовой программе значение корректно.

## exFat
Результат работы тестовой программы:

```
tf_type: FUSE 0x65735546
tf_namelen: 255
```

Файловая система exFAT поддерживается в ядре начиная с версии 5.4, до этого момента создание производилось с помощью FUSE. Удалили пакет exFAT-FUSE:

```
sudo apt-get autoremove exfat-fuse
```

После удаления пакета, создание рассматриваемой файловой системы стало невозможно. 

Установили отдельно пакет exfatprogs:

```
epm --auto install exfatprogs
```

Запустили тестовую программу еще раз, получили следующие результаты:

```
tf_type: exFAT 0x2011bab0
tf_namelen: 1530
```
Рассмотрим, как это значение вычисляется в ядре:

```
f_namelen = EXFAT_MAX_FILE_LEN * NLS_MAX_CHARSET_SIZE;
```

Константа EXFAT\_MAX\_FILE\_LEN равная 255 находится в файле fs/exfat/exfat_raw.h, а NLS\_MAX\_CHARSET\_SIZE в include/linux/nls.h и равняется 6.

Таким образом, мы убедились, что полученное в тестовой программе значение корректно.

## ext4
Результат работы тестовой программы:

```
tf_type: EXT4 0xef53
tf_namelen: 255
```

Рассмотрим как данное значение вычисляется в ядре:

```
f_namelen = EXT4_NAME_LEN;
```

Константа EXT4\_NAME\_LEN равная 255 находится в файле fs/exfat/ext4.h.

Таким образом, мы убедились, что полученное в тестовой программе значение корректно.

## btrfs
Для создания файловой системы установили пакет btrfs-progs:

```
epm --auto install btrfs-progs
```

Результат работы тестовой программы:

```
tf_type: BTRFS 0x9123683e
tf_namelen: 255
```

Рассмотрим как данное значение вычисляется в ядре:

```
f_namelen = BTRFS_NAME_LEN;
```

Константа BTRFS\_NAME\_LEN равная 255 находится в файле fs/btrfs/ctree.h.

Таким образом, мы убедились, что полученное в тестовой программе значение корректно.

## NTFS

На момент проведения тестирования файловая система NTFS поддерживается в ядре только в режиме чтения. Пакет, который позволяет создавать ее, поставляется вместе с ntfs-3g, реализующий работу с NTFS через FUSE, установили его: 

```
epm --auto install ntfs-3g
```

Рассматриваемая файловая система монтируется только в виде блочного устройства. Нашли свободное петлевое устройство:

```
losetup -f
```

Привязали наш файл к нему, для взаимодействия с ним как с обычным блочным:

```
losetup $(losetup -f) ntfs.txt
```

Создали на данном устройстве NTFS, примонтировали его в директорию с указанием типа файловой системы и запустили тестовую программу, получили следующие результаты:

```
tf_type: FUSE 0x65735546
tf_namelen: 255
```

Оказалось, что установленный пакет ntfs-3g перекрывает реализацию NTFS в ядре, так как имеет то же название типа при вызове mount. Установить отдельно пакет для создания NTFS не представлялось возможным, удалили его после создания файловой системы, примонтировали блочное устройство и запустили тестовую программу, получили следующие результаты:

```
tf_type: NTFS 0x5346544e
tf_namelen: 255
```

Рассмотрим как данное значение вычисляется в ядре:

```
f_namelen = NTFS_MAX_NAME_LEN;
```

Константа NTFS\_MAX\_NAME\_LEN равная 255 находится в файле fs/ntfs/ntfs.h.

Таким образом, мы убедились, что полученное в тестовой программе значение корректно.